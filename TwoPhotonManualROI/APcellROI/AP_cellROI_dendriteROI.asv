function AP_cellROI_dendriteROI

save_flag = true;

[summed_filenames, summed_path] = uigetfile('*.tif','Choose tiff files','multiselect','on');
if ~iscell (summed_filenames)
    summed_filenames = {summed_filenames};
end
summed_filenames = sort(summed_filenames);

n_sessions = length(summed_filenames);

dir_sep = strfind(summed_path,filesep);
animal = summed_path(dir_sep(end-1)+1:dir_sep(end)-1);

M = 512;
N = 512;

disp('Summing activity within sessions')

summed_max = double(nan(M,N,n_sessions));
summed_mean = double(nan(M,N,n_sessions));
% Loop through sessions, get max/avg projection
for curr_session = 1:n_sessions
    
    % Get max projection of day
    curr_file = [summed_path filesep summed_filenames{curr_session}];
    
    im_info = imfinfo(curr_file);
    n_frames = length(im_info);
    
    % Load in current day    
    im = zeros(M,N,n_frames,'uint16');
    for i = 1:n_frames
        im(:,:,i) = imread(curr_file,'tiff',i,'Info',im_info);
    end

    summed_max(:,:,curr_session) = max(im,[],3);
    summed_mean(:,:,curr_session) = mean(im,3);
    
    disp(['Loading for alignment, session: ' num2str(curr_session)]);
    
    clear im
end

% Register days to each other
disp('Registering maximum projections')
tform_matrix = cell(n_sessions,1);
tform_matrix{1} = eye(3);


summed_max_reg = nan(size(summed_max));
summed_max_reg(:,:,1) = summed_max(:,:,1);
summed_mean_reg = nan(size(summed_mean));
summed_mean_reg(:,:,1) = summed_mean(:,:,1);
for curr_session = 2:n_sessions

    [optimizer, metric] = imregconfig('monomodal');
    optimizer.MaximumStepLength = 0.02;%0.0001;
    %optimizer.RelaxationFactor = 0.1;
    %optimizer.GradientMagnitudeTolerance = 1e-6;
    %optimizer.MaximumIterations = 300;
    
    % Perform the registration on the maximum image
    tformEstimate = imregtform(summed_max(:,:,curr_session),summed_max(:,:,1),'affine',optimizer,metric);
    %tformEstimate = imregcorr(summed_max(:,:,curr_session),summed_max(:,:,1),'similarity');
    
    max_im_reg = imwarp(summed_max(:,:,curr_session),tformEstimate,'Outputview',imref2d([M N]));
    mean_im_reg = imwarp(summed_mean(:,:,curr_session),tformEstimate,'Outputview',imref2d([M N]));
    
    tform_matrix{curr_session} = tformEstimate.T;
    summed_max_reg(:,:,curr_session) = max_im_reg;
    summed_mean_reg(:,:,curr_session) = mean_im_reg;
    
end

% Human-verify registration (if it isn't near-perfect, don't use)
gui_fig = AP_image_scroll(summed_max_reg);
check_alignment = input('Perfect alignment (y/n)?: ','s');

if ~strcmp(check_alignment,'y')
    keyboard
end
    
%%%% THIS IS THE NEWEST VERSION, CENTROIDS OF THRESHOLDED ACTIVE SPOTS    
% If this ends up working: can get rid of the 'activity' part above    

% THIS IS ARBITRARY AT THE MOMENT: DEFINE BETTER
fluor_threshold = 500;


active_centroids = zeros(512,512);

for curr_session = 1:length(summed_filenames)
    
    curr_file = [summed_path filesep summed_filenames{curr_session}];
    im_info = imfinfo(curr_file);
    n_frames = length(im_info);
    
    % Load in current day, align, make average
    im = zeros(M,N,n_frames,'uint16');
    for i = 1:n_frames
        curr_frame = imread(curr_file,'tiff',i,'Info',im_info);
        curr_tform = affine2d;
        curr_tform.T = tform_matrix{curr_session};
        im_reg = imwarp(curr_frame,curr_tform,'Outputview',imref2d([M N]));
        im(:,:,i) = im_reg;
    end
    curr_avg = nanmean(double(im),3);
    
    % Process image
    im_processed_reshape = zeros(M*N,n_frames);
    for i = 1:n_frames
        curr_frame = double(im(:,:,i));
        curr_frame_sharp = imsharpen(curr_frame,'Radius',2,'Amount',2);
        curr_frame_norm = (double(curr_frame)-double(curr_avg));
        
        im_processed_reshape(:,i) = curr_frame_norm(:);
        
        stats = regionprops(curr_frame_norm >= fluor_threshold);
        active_centroids_sub = round(vertcat(stats.Centroid));
        active_centroids_ind = sub2ind([M,N],active_centroids_sub(:,2), ...
            active_centroids_sub(:,1));
        
        active_centroids(active_centroids_ind) = active_centroids(active_centroids_ind)+1;
    end
    
    disp(['Active centroids, session: ' num2str(curr_session)]);
    
end

active_centroids_max = imextendedmax(active_centroids,2);
%active_centroids_max = imregionalmax(active_centroids);

% Force borders to zero
x_crop_px = 25;
y_crop_px = 15;
border_idx = true(size(active_centroids_max));
border_idx(y_crop_px:end-y_crop_px+1,x_crop_px:end-x_crop_px+1) = false;
active_centroids_max(border_idx) = false;

% Eliminate active centers that are close to other active centers
max_dist = 5;
cc = bwconncomp(active_centroids_max);
active_centroid_rois = cc.PixelIdxList;
close_roi = false(length(active_centroid_rois),1);
for i = 1:length(active_centroid_rois)
   temp_map = active_centroids_max;
   temp_map(active_centroid_rois{i}) = 0;
   temp_dist = bwdist(temp_map); 
   close_roi(i) = any(temp_dist(active_centroid_rois{i}) < max_dist);
end
active_centroid_rois(close_roi) = [];

% Once centers gotten, go through thresholded images
% and get median shape of objects selected by their centers
roi_active_px = zeros(M,N,length(active_centroid_rois));
roi_active_frames = zeros(length(active_centroid_rois),1);
for curr_session = 1:length(summed_filenames)
    
    curr_file = [summed_path filesep summed_filenames{curr_session}];
    im_info = imfinfo(curr_file);
    n_frames = length(im_info);
    
    % Load in current day, align, make average
    im = zeros(M,N,n_frames,'uint16');
    for i = 1:n_frames
        curr_frame = imread(curr_file,'tiff',i,'Info',im_info);
        curr_tform = affine2d;
        curr_tform.T = tform_matrix{curr_session};
        im_reg = imwarp(curr_frame,curr_tform,'Outputview',imref2d([M N]));
        im(:,:,i) = im_reg;
    end
    curr_avg = nanmean(double(im),3);
    
    % Process image
    im_thresh = false(512,512,size(im,3));
    for i = 1:n_frames
        curr_frame = double(im(:,:,i));
        curr_frame_sharp = imsharpen(curr_frame,'Radius',2,'Amount',2);
        curr_frame_norm = (double(curr_frame)-double(curr_avg));
        curr_frame_thresh = curr_frame_norm >= fluor_threshold;

        im_thresh(:,:,i) = curr_frame_thresh;
    end
    
    % Find frames where ROI is active (centroid = 1);
    for curr_roi = 1:length(active_centroid_rois)
        [curr_y curr_x] = ind2sub([M,N],active_centroid_rois{curr_roi});
        active_frames = any(cell2mat(arrayfun(@(x) im_thresh(curr_y(x),curr_x(x),:),1:length(curr_y),'uni',false)),2);
        active_px = nansum(im_thresh(:,:,active_frames),3);
        
        roi_active_px(:,:,curr_roi) = roi_active_px(:,:,curr_roi) + active_px;
        roi_active_frames(curr_roi) = roi_active_frames(curr_roi) + sum(active_frames);       
    end
    
    disp(['Active shape, session: ' num2str(curr_session)]);
    
end

% Find the shape for each ROI
frac_active_frames = 0.5;

dilate_size = 1;
dilate_filt = fspecial('disk',dilate_size);

roi_mask = zeros(M,N,length(active_centroid_rois));
for curr_roi = 1:length(active_centroid_rois)    
    [curr_y curr_x] = ind2sub([M,N],active_centroid_rois{curr_roi});
    roi_mask(:,:,curr_roi) = bwselect(roi_active_px(:,:,curr_roi) >= roi_active_frames(curr_roi)*frac_active_frames,curr_x,curr_y); 
    
    % If it's less than 10 pixels, dilate
    if sum(reshape(roi_mask(:,:,curr_roi),[],1)) < 10
       roi_mask(:,:,curr_roi) = conv2(roi_mask(:,:,curr_roi),+dilate_filt,'same') > 0; 
    end
end

% Sometimes multiple centers are picked up for the same ROI where one is
% inside of the other. Look for large overlaps, delete the larger one.
overlap_frac_thresh = 0.5;

roi_overlap_px = reshape(roi_mask,[],size(roi_mask,3))'*reshape(roi_mask,[],size(roi_mask,3));
roi_px = sum(reshape(roi_mask,[],size(roi_mask,3)));
roi_min_px = min(cat(3,repmat(roi_px,size(roi_mask,3),1), ...
    repmat(roi_px,size(roi_mask,3),1)'),[],3);
roi_overlap_frac = tril((roi_overlap_px./roi_min_px),-1) > overlap_frac_thresh;
[roi_1,roi_2] = ind2sub(repmat(size(roi_mask,3),2,1),find(roi_overlap_frac));
remove_overlying_roi = unique([roi_1((roi_px(roi_1) > roi_px(roi_2))); ...
    roi_2((roi_px(roi_2) > roi_px(roi_1)))]);

roi_mask(:,:,remove_overlying_roi) = [];

% Get rid of remaining overlap with buffer zone
dilate_size = 1;
dilate_filt = fspecial('disk',dilate_size);

overlapping_px = conv2(+(sum(roi_mask,3) > 1),+dilate_filt,'same') > 0;
roi_mask(repmat(overlapping_px,1,1,size(roi_mask,3))) = 0;

% Make buffer zone next to immediate neighbors
dilate_size = 1;
dilate_filt = fspecial('disk',dilate_size);

neighboring_px = sum(convn(+roi_mask,dilate_filt,'same') > 0,3) > 1;
roi_mask(repmat(overlapping_px,1,1,size(roi_mask,3))) = 0;

% Delete any ROIs which are too small after this process


% Reverse-align ROIs for each session, draw polygon
disp('Creating ROIs (%):')
fprintf('%2d',0)
roi_polygon = cell(n_sessions,1);
for curr_session = 1:n_sessions;
    
    % make reverse registration transform matrix
    curr_tform = affine2d;
    inverse_tform = inv(tform_matrix{curr_session});
    % inverse is not perfect: force last column
    inverse_tform(1:2,3) = 0;
    inverse_tform(3,3) = 1;
    curr_tform.T = inverse_tform;
    
    for curr_roi = 1:size(roi_mask,3);
        
        binaryCell = roi_mask(:,:,curr_roi);
        
        % reverse register cell to fit session
        binaryCell_reg = +(imwarp(binaryCell,curr_tform,'Outputview',imref2d([M N])) > 0);
        
        % If registering pushes ROI off edge, ignore now and delete later
        if sum(binaryCell_reg(:)) == 0
            continue
        end
        
        first_nonzero = find(binaryCell_reg > 0,1);
        [y_nonzero x_nonzero] = ind2sub([M N],first_nonzero);
        roi_edge = bwtraceboundary(binaryCell_reg,[y_nonzero x_nonzero],'N'); % find boundary, in order
        
        % get difference in distance to center across border
        % function from file exchange
        if size(roi_edge,1) > 10
            num_verticies = 10;
            roi_edge_downsample = reduce_poly(roi_edge',num_verticies)';
        end
              
        % make x,y coordinates
        roi_polygon{curr_session}{curr_roi} = fliplr(roi_edge_downsample);
        
    end
    fprintf('%c%c%2d',8,8,round(100*curr_session/n_sessions));
end


% Delete any ROIs that are not present / off edge after aligning
offscreen_rois = any(cell2mat(cellfun(@(x) cellfun(@(x) isempty(x), x'), roi_polygon','uni',false)),2);
roi_polygon_use = cellfun(@(x) x(~offscreen_rois),roi_polygon,'uni',false);

% Save the ROI polygons
if save_flag
    save_path = [summed_path animal '_batch_thresh_roi'];
    if ~exist(save_path,'dir')
        mkdir(save_path)
    end
    for curr_session = 1:n_sessions;
        clear polygon
        polygon.ROI = roi_polygon_use{curr_session};
        
        curr_save_filename = [save_path filesep summed_filenames{curr_session}(1:end-4) '.roi'];
        save(curr_save_filename,'polygon');
    end
end

% This was from old one, make it work with new one preferably

% 
% %%% Human verification of ROIs
% 
% % Draw ROIs on the aligned images for inspection
% cc = bwconncomp(activity_thresh_split_clean);
% rois = cc.PixelIdxList;
% figure(gui_fig)
% for curr_roi = 1:length(rois)
%     % Get verticies for ROI
%     binaryCell = zeros(size(activity_thresh_split_clean(:,:,1)));
%     binaryCell(rois{curr_roi}) = 1;
%     
%     first_nonzero = find(binaryCell > 0,1);
%     [y_nonzero x_nonzero] = ind2sub([M N],first_nonzero);
%     roi_edge = bwtraceboundary(binaryCell,[y_nonzero x_nonzero],'N'); 
%     
%     roi_edge(end+1,:) = roi_edge(1,:);
%     
%     line(roi_edge(:,2),roi_edge(:,1));
%     
% end
% 
% % Draw borders to know what's been excluded
% line([x_crop_px,M-x_crop_px+1],[y_crop_px,y_crop_px],'color','r');
% line([x_crop_px,x_crop_px],[y_crop_px,N-y_crop_px+1],'color','r');
% line([x_crop_px,M-x_crop_px+1],[N-y_crop_px+1,N-y_crop_px+1],'color','r');
% line([M-x_crop_px+1,M-x_crop_px+1],[y_crop_px,N-y_crop_px+1],'color','r');
% 

